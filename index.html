<!doctype html>
<html lang="en">

<head>
    <link rel="stylesheet" href="./css/bootstrap.min.css">
    
    <script src="./js/bootstrap.min.js"></script>
    <script src="./js/bootstrap.bundle.min.js"></script>
    <script src="./js/prism.js" data-manual></script>
    <script src="./js/custom.js"></script>
    <script src="./js/p5.min.js"></script>

</head>

<body>

    <nav class="navbar navbar-expand-lg bg-dark" data-bs-theme="dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Strona Milki</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarColor02"
                aria-controls="navbarColor02" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarColor02">
                <ul class="navbar-nav me-auto">
                    <li class="nav-item">
                        <a class="nav-link active" href="#">Strona główna
                            <span class="visually-hidden">(current)</span>
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#Roblox">O mnie na Roblox</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#Fortnite">O mnie na Fortnite</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#tiktok">O mnie na Tik tok</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" data-bs-toggle="dropdown" href="#" role="button"
                            aria-haspopup="true" aria-expanded="false">Dropdown</a>
                        <div class="dropdown-menu">
                            <a class="dropdown-item" href="#">Action</a>
                            <a class="dropdown-item" href="#">Another action</a>
                            <a class="dropdown-item" href="#">Something else here</a>
                            <div class="dropdown-divider"></div>
                            <a class="dropdown-item" href="#">Separated link</a>
                        </div>
                    </li>
                </ul>
               
            </div>
        </div>
    </nav>
    
    <div id="myTabContent" class="tab-content">
        <div class="tab-pane fade active show" id="home" role="tabpanel">
            <p>Moja strona internetow na króre dowiesz się o mnie więcej.</p>
        </div>
    </div>

    <div class="alert alert-dismissible alert-warning">
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        <h4 class="alert-heading">Uwaga</h4>
        <p class="mb-0">Zapraszam na mojego tik toka @milana.g11 <a href="#" class="alert-link"></a>.</p>
    </div>
     <img width="150px" src="https://th.bing.com/th/id/OIP.ANZlA13jEMoOKOVhRiDcxQAAAA?rs=1&pid=ImgDetMain&adlt=strict" />
    <ul class="list-group" id="tiktok">
        <li class="list-group-item list-group-item-primary d-flex justify-content-between align-items-center">

            <span class="badge bg-primary rounded-pill">Na dole</span>
            Co nagrywam na Tik toku?

        </li>
        

    </ul>
    <div class="card text-white bg-secondary mb-3" style="max-width: 20rem;">
        <div class="card-header">Tik Tok</div>
        <div class="card-body">
          <h4 class="card-title">Zobacz profil</h4>
          <p class="card-text">Ogólnie to gry ale może dodam rysowanie.</p>
          <div>
            <blockquote class="tiktok-embed" cite="https://www.tiktok.com/@milana.g11/video/7325445345226362144"
                data-video-id="7325445345226362144" style="max-width: 605px;min-width: 325px; scale: 50%;">
                <section> <a target="_blank" title="@milana.g11"
                        href="https://www.tiktok.com/@milana.g11?refer=embed">@milana.g11</a> Kolejne? <a
                        title="roblox" target="_blank"
                        href="https://www.tiktok.com/tag/roblox?refer=embed">#Roblox</a> <a target="_blank"
                        title="♬ dźwięk oryginalny - Milka"
                        href="https://www.tiktok.com/music/dźwięk-oryginalny-7325445657384520481?refer=embed">♬
                        dźwięk oryginalny - Milka</a> </section>
            </blockquote>
            <script async src="https://www.tiktok.com/embed.js"></script>
        </div>
        </div>
      </div>
      <div class="card text-white bg-secondary mb-3" style="max-width: 100%;">
        <div class="card-header">Tik Tok</div>
        <div class="card-body">
          <h4 class="card-title">Zobacz profil</h4>
          <p class="card-text">Ogólnie to gry ale może dodam rysowanie.</p>
          <div>
            <main>
            </main>
        </div>
        </div>
      </div>
      <script lang="javascript">
        //
// Corso di Coding con p5js
// Autore: A.Erriquez
// (c) 2022
// 
// Lezione 5-4: migliorie interfaccia utente (UI)
// 
// Argomenti:
// - barra di stato
//
// Esercizi
// - 
//

// dimensione canvas
const SIZE = 450;
// dimensione cella
const CELL_SIZE = SIZE / 3;
// dimensione simbolo
const SYMBOL_SIZE = SIZE / 4;
// dimensione barra di stato
const STATUS_BAR_H = 20

// array per le caselle
let cells = [];

// ciascun elemento rappresenta una casella, le righe sono messe in sequenza
// *-----*-----*-----*
// *     *     *     *
// *  0  *  1  *  2  *
// *     *     *     *
// *-----*-----*-----*
// *     *     *     *
// *  3  *  4  *  5  *
// *     *     *     *
// *-----*-----*-----*
// *     *     *     *
// *  6  *  7  *  8  *
// *     *     *     *
// *-----*-----*-----*

// giocatore iniziale
let firstPlayer = 'X';
// giocatore corrente
let nowPlaying = 'X';

// numero celle utilizzate
let usedCells = 0;
// gioco terminato?
let gameOver = false;
// vincitore (se gioco terminato)
let winner = null;

// giocatore virtuale
const virtualPlayer = 'O';
// giocatore "umano"
const humanPlayer = 'X';

// score di X e O
let score;

// stato del gioco
// HUMAN : in attesa di mossa da giocatore umano
// SIMULATION : mostra simulazione gioco
let state = "HUMAN";

// numero di millisecondi da attendere tra una simulazione e la successiva
const SIMULATION_DELAY_MS=200;

function setup() {
  createCanvas(SIZE, SIZE + STATUS_BAR_H);

  resetGame();
}

// reset (gioco e score)
function resetGame()
{
  score = {'X':0, 'O': 0},
    
  initGame();
}

// nuovo gioco
function initGame()
{
  // cambio giocatore iniziale ad ogni partita
  nowPlaying = firstPlayer==='X' ? 'O' : 'X';
  firstPlayer = nowPlaying;
  
  // reset celle utilizzate e gameOver
  usedCells = 0;
  gameOver = false;
  winner = null;
  
  // crea celle
  cells = [];
  // riempie con x e y della griglia e nessun owner
  for (let i=0; i<9; i++) {
    cells.push(
        {
            x: i % 3,
            y: int(i / 3),
            owner: null,
            simulated: false,
        }
    )
  }
  
    // se il gioco non e' terminato ed il giocatore e' virtuale
    if (nowPlaying===virtualPlayer) {
      makeNextMove();
    }
}

// controlla se la cella sia utilizzata
// passaggio di struttura con attributi x e y, viene destrutturata nella dichiarazione di funzione
function isCellUsed({ x, y })
{
  // calcolo indice in array rispetto a coordinate
  const index = x + y * 3;

  // fuori range
  if (index<0 || index>=cells.length)
    return undefined;

  return cells[index].owner !== null;
}

// disegna cella
// pos: oggetto {x.y} che indica posizione nella griglia
// owner: 'X' o 'O'
// color: colore da utilizzare
function drawCell(pos,owner,color,simulated)
{
  if (pos.x<0 || pos.x>2 || pos.y<0 || pos.y>2)
    return;
    
  strokeWeight(simulated ? 1 : 3);
  stroke(color);

  // calcola centro del simbolo rispetto al canvas
  const center = {
    x: CELL_SIZE/2 + pos.x * CELL_SIZE,
    y: CELL_SIZE/2 + pos.y * CELL_SIZE,
  }

  switch (owner) {
    // 'X' due linee diagonali
    case 'X':
      line(center.x-SYMBOL_SIZE/2,center.y-SYMBOL_SIZE/2,center.x+SYMBOL_SIZE/2,center.y+SYMBOL_SIZE/2);
      line(center.x-SYMBOL_SIZE/2,center.y+SYMBOL_SIZE/2,center.x+SYMBOL_SIZE/2,center.y-SYMBOL_SIZE/2);
      break;
    // 'O': una circonferenza
    case 'O':
      circle(center.x,center.y,SYMBOL_SIZE/2);
      break;
  }
}

// verifica se il gioco e' terminato
// per evitare di navigare su tutte le celle controlla rispetto ad ultima mossa
function checkGameOver(lastMove, useCells, simulation)
{
  // l'ultimo che ha mosso potrebbe aver vinto
  const potWinner = lastMove.owner;
  
  // riga
  // si ipotizza abbia vinto
  let fail = false;
  // controlla le celle della riga
  for (let c=0; c<3 && !fail; c++) {
    const index = lastMove.y*3 + c;
    // se una cella e' diversa dal potenziale vincitore allora ci si ferma
    if (useCells[index].owner!==potWinner)
      fail = true;
  }
  // se non e' mai entrato in fail = true allora sono tutte uguali
  if (!fail) {
    if (simulation===true)
        return potWinner;
    // memorizza vincitore
    winner = potWinner;
    // gioco terminato
    gameOver = true;
  }
  
  // colonna, stesso algoritmo
  fail = false;
  for (let r=0; r<3 && !fail; r++) {
    const index = r*3 + lastMove.x;
    if (useCells[index].owner!==potWinner)
      fail = true;
  }
  if (!fail) {
    if (simulation===true)
        return potWinner;
    winner = potWinner;
    gameOver = true;
  }
  
  // diagonali controllate solo se ultima mossa e' su una delle due
  if (lastMove.x===lastMove.y || lastMove.x===(2-lastMove.y)) {
    // diagonale NE-SO
    fail = false;
    for (let r=0; r<3 && !fail; r++) {
      const index = r*3 + r;
      if (useCells[index].owner!==potWinner)
        fail = true;
    }
    if (!fail) {
      if (simulation===true)
        return potWinner;
      winner = potWinner;
      gameOver = true;
    }
    
    // diagonale NO-SE
    fail = false;
    for (let r=0; r<3 && !fail; r++) {
      const index = (2-r)*3 + r;
      if (useCells[index].owner!==potWinner)
        fail = true;
    }
    if (!fail) {
      if (simulation===true)
        return potWinner;
      winner = potWinner;
      gameOver = true;
    }
  }
  
  // se tutte le celle sono state utilizzate (e non e' stato trovato un vincitore)
  if (usedCells===9 && !gameOver) {
    // nessun vincitore, ma gioco termina comunque
    gameOver = true;
  }
  
  // aggiorna score
  if (gameOver && winner!==null) {
    score[winner]++;
  }
}

let simulationContext;

function makeNextMove()
{
  state = "SIMULATION";

  // seconda versione: "base", sceglie una cella guardando solo una mossa in avanti
  const simulatedCells = cells.map(c => { return {...c}});

  // tra le celle ancora libere
  const availCells = simulatedCells.filter((c) => c.owner===null);

  simulationContext = {
    simulatedCells,
    availCells,
    index: 0,
    weightedCells: [],
  }
  
  updateSimulation();
}

function updateSimulation()
{
  const prevCell = simulationContext.index===0 ? undefined : simulationContext.availCells[simulationContext.index-1];
  if (prevCell!==undefined) {
    cells[prevCell.x+prevCell.y*3].owner = null;
    cells[prevCell.x+prevCell.y*3].simulated = false;    
  }
  
  if (simulationContext.index===simulationContext.availCells.length) {
      simulationContext.weightedCells.sort((a,b) => a.weight - b.weight);

      const bestWeight = simulationContext.weightedCells[simulationContext.weightedCells.length-1].weight;
    
      const bestCells = simulationContext.weightedCells.filter(c => c.weight===bestWeight)
    
      // sceglie a caso tra le migliori
      let selectedCell = random(bestCells);
      
      // trova la stessa cella nell'array iniziale
      // si potrebbe anche usare index
      selectedCell = cells.find(c => c.x===selectedCell.x && c.y===selectedCell.y);
      
      // sanity check
      if (selectedCell!==undefined) {
        selectedCell.owner = virtualPlayer;
    
        usedCells++;
    
        checkGameOver(selectedCell,cells,false);
      }
      
      // cambio giocatore
      nowPlaying = nowPlaying==='X' ? 'O' : 'X';    
      
      state = "HUMAN";
    
    return;
  }
  
  const curCell = simulationContext.availCells[simulationContext.index];
  cells[curCell.x+curCell.y*3].owner = virtualPlayer;
  cells[curCell.x+curCell.y*3].simulated = true;

    usedCells++;

    let weight = 0;
    
    curCell.owner = virtualPlayer;
    const win1 = checkGameOver(curCell,simulationContext.simulatedCells,true);
    if (win1===virtualPlayer) {
        weight = 10;
    }
    
    curCell.owner = humanPlayer;
    const win2 = checkGameOver(curCell,simulationContext.simulatedCells,true);
    if (win2===humanPlayer) {
        weight = 10;
    }

    usedCells--;
    
    curCell.owner = null;

    simulationContext.weightedCells.push({
        ...curCell,
        weight
    });

    simulationContext.index++;
    setTimeout(updateSimulation,SIMULATION_DELAY_MS);
}

function draw() {
  background(40);

  // griglia
  strokeWeight(1);
  stroke(255);
  line (0,CELL_SIZE,SIZE,CELL_SIZE);
  line (0,2*CELL_SIZE,SIZE,2*CELL_SIZE);
  line (CELL_SIZE,0,CELL_SIZE,SIZE);
  line (2*CELL_SIZE,0,2*CELL_SIZE,SIZE);

  noFill();

  // disegna celle impegnate
  for (const cell of cells) {
    if (cell.owner!==null)
      // crea oggetto {x,y} "on-the-fly"
      // si potrebbe anche passare cell
      // colore determinato con operatore ternario: 'X' in verde, 'O' in rosso
      drawCell({x: cell.x, y: cell.y}, cell.owner, cell.owner==='X' ? 'green' : 'red', cell.simulated);
  }

  // posizione del cursore rispetto alla griglia
  const pos = {x: int(mouseX/CELL_SIZE), y: int(mouseY/CELL_SIZE) };
  
  // se la cella e' libera ed il gioco e' in corso (ed eì un giocatore "umano")
  if (!isCellUsed(pos) && !gameOver && virtualPlayer!==nowPlaying) {
    // disegna proposta cella
    drawCell(pos, nowPlaying,'white',false);
  }

  if (!gameOver) {
    stroke(0);
    fill(200);
    textSize(12);
    textAlign(CENTER);
    
    if (state==="SIMULATION") {
        text("'O' is thinking....",SIZE/2, height-STATUS_BAR_H/2);
    }
    else {
        text("Your turn",SIZE/2, height-STATUS_BAR_H/2);
    }
  }
  else {
    stroke(0);
    fill('white');
    textSize(12);
    textAlign(CENTER);
    text("Press 'n' for new game, 'r' to restart",SIZE/2, height-STATUS_BAR_H/2);
  }
  
  // score
  stroke(0);
  textSize(18);
  textAlign(LEFT);
  fill('green');
  text("X: " + score['X'], 10, height-STATUS_BAR_H/2);
  fill('red');
  textAlign(RIGHT);
  text("O: " + score['O'], width-10, height-STATUS_BAR_H/2);

  // gioco terminato
  if (gameOver) {    
    strokeWeight(1);
    stroke('white');
    fill('white');
    textSize(32);
    textAlign(CENTER);
    
    switch (winner) {
      case 'X':
        // 'X' vince
        text("X wins!",SIZE/2, SIZE/2);
        break;
      case 'O':
        // 'O' vince
        text("O wins!",SIZE/2, SIZE/2);
        break;
      default:
        // nessun vincitore
        text("NO WINNER",SIZE/2, SIZE/2);
        break;
    }
  }
}

function mousePressed()
{
  // posizione del cursore rispetto alla griglia
  const p = {
    x: int(mouseX / CELL_SIZE),
    y: int(mouseY / CELL_SIZE),
  }

  // se la cella e' libera
  // controlla che sia un giocatore "umano"
  if (!isCellUsed(p) && virtualPlayer!==nowPlaying) {
    // calcola indice rispetto ad array
    const index = p.x + 3 * p.y;

    // in range
    if (index>=0 && index<cells.length) {
      // alloca cella a giocatore
      cells[index].owner = nowPlaying;
      
      usedCells++;
      
      // cambio giocatore
      nowPlaying = nowPlaying==='X' ? 'O' : 'X';
      
      checkGameOver(cells[index], cells, false);

      // se il gioco non e' terminato ed il giocatore e' virtuale
      if (!gameOver && nowPlaying===virtualPlayer) {
        makeNextMove();
      }
    }
  }
}

function keyPressed()
{
  // evento pressione sulla tastiera
  // key indica il tasto premuto
  
  if (key==='r') {
    // r => reset
    resetGame();
  }
  if (key==='n') {
    // n => nuova partita
    initGame();
  }
}

      </script>
</body>